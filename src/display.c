#include "display.h"
#include "cmsis_os2.h"
#include "main.h"

#define DISPLAY_TIMEOUT_MS 5000

static uint8_t LED[] = {
  0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 
  0xCF, 0xCF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 
  0xF0, 0xF0, 0xF0, 0xF0, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 
  0xF0, 0xF0, 0xF0, 0xF0, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xF3, 0xF3, 0xF3, 0xF3, 0xF3, 0xF3, 
  0xF3, 0xF3, 0xF3, 0xF3, 0xF3, 0xF3, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0xF0, 0xF0, 0xF0, 
  0xF0, 0xF0, 0xF0, 0xF0, 0x0F, 0x0F, 0x0F, 0x0F
};

static uint8_t PWM[] = {
  0xFF, 0xFF, 0xFF, 0xFF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 
  0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x0F, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 
  0x03, 0x03, 0x03, 0x03, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0xF0, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xF0, 0xF0, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 
  0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF
};

static uint8_t LED_OFF[] = {
  0xFF, 0xFF, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x83, 0x83, 
  0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x00, 0x00, 0xFF, 0xFF, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 
  0x83, 0x83, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xFF, 0xFF, 0x00, 0x00, 
  0xFF, 0xFF, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0xFF, 0xFF, 0x01, 0x01, 
  0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

static uint8_t LED_ON[] = {
  0xFF, 0xFF, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x18, 0x18, 
  0x60, 0x60, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xFF, 0xFF, 0x00, 0x00, 
  0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x06, 0x06, 0x18, 0x18, 0xFF, 0xFF, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

static uint8_t LED_BLINK[] = {
  0xFF, 0xFF, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x7C, 0x7C, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x18, 0x18, 0x60, 0x60, 0x80, 0x80, 
  0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 
  0x60, 0x60, 0x1F, 0x1F, 0xFF, 0xFF, 0xC1, 0xC1, 0xC1, 0xC1, 0xC1, 0xC1, 0x3E, 0x3E, 0x00, 0x00, 
  0xFF, 0xFF, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 
  0x00, 0x00, 0x01, 0x01, 0x06, 0x06, 0x18, 0x18, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x01, 0x01, 
  0x01, 0x01, 0x01, 0x01, 0x06, 0x06, 0xF8, 0xF8
};

// static uint8_t LED_BREATH[] = {
//   0xFF, 0xFF, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x7C, 0x7C, 0x00, 0x00, 0xFF, 0xFF, 0x83, 0x83, 
//   0x83, 0x83, 0x83, 0x83, 0x7C, 0x7C, 0x00, 0x00, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0xFF, 0xFF, 
//   0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x00, 0x00, 0xFF, 0xFF, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 
//   0x80, 0x80, 0xFF, 0xFF, 0xFF, 0xFF, 0xC1, 0xC1, 0xC1, 0xC1, 0xC1, 0xC1, 0x3E, 0x3E, 0x00, 0x00, 
//   0xFF, 0xFF, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0xFE, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
//   0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x01, 0x01, 
//   0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0xFF, 0xFF
// };

// static uint8_t LED_STATES

static gui_digits DISPLAY_DIGITS = {
  .spacing = 2,
  .bytes = {
    {0xFF, 0xFF, 0x0F, 0x0F, 0x0F, 0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0xF0, 0xF0, 0xF0, 0xFF, 0xFF},
    {0x0F, 0x0F, 0x0F, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0xF0, 0xF0, 0xF0, 0xFF, 0xFF, 0xF0, 0xF0, 0xF0},
    {0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF3, 0xF3, 0xF3, 0xF3, 0xF3, 0xF3},
    {0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xFF, 0xFF, 0xF3, 0xF3, 0xF3, 0xF3, 0xF3, 0xF3, 0xFF, 0xFF},
    {0xFF, 0xFF, 0xC0, 0xC0, 0xC0, 0xC0, 0xFF, 0xFF, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0xFF, 0xFF},
    {0xFF, 0xFF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xF3, 0xF3, 0xF3, 0xF3, 0xF3, 0xF3, 0xFF, 0xFF},
    {0xFF, 0xFF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xFF, 0xFF, 0xF3, 0xF3, 0xF3, 0xF3, 0xFF, 0xFF},
    {0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF},
    {0xFF, 0xFF, 0xCF, 0xCF, 0xCF, 0xCF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF3, 0xF3, 0xF3, 0xF3, 0xFF, 0xFF},
    {0xFF, 0xFF, 0xCF, 0xCF, 0xCF, 0xCF, 0xFF, 0xFF, 0xF3, 0xF3, 0xF3, 0xF3, 0xF3, 0xF3, 0xFF, 0xFF}
  }
};

uint8_t buffer[8 * 128];
static uint8_t init_cmds[] = {
    SH1106_SET_DISPLAY | 0x00,
    SH1106_SET_DIV_RATIO,
    0x50,
    SH1106_SET_MUX_RATIO,
    0x3F,
    SH1106_SET_DISPLAY_OFFSET,
    0x00,
    SH1106_SET_START_LINE | 0x00,
    SH1106_SET_REMAP | 0x00,
    SH1106_SET_COM_DIR | 0x00,
    SH1106_SET_COMMMON_PADS,
    0x12,
    SH1106_SET_CONTRAST,
    0x9F,
    SH1106_SET_CHARGE_PERIOD,
    0x22,
    SH1106_SET_VCOM,
    0x40,
    SH1106_SET_ENTIRE_DISPLAY | 0x00,
    SH1106_SET_NORMAL_DISPLAY | 0x00,
    SH1106_SET_DISPLAY | 0x01
};

void send_cmd(uint8_t cmd);
void send_data(uint8_t *data, uint8_t len);
void sh1106_delay(uint32_t delay);
void sh1106_set(sh1106_pin *pin, bool state);
void sh1106_write(sh1106_ctx *ctx, uint8_t *data, const uint8_t n_bytes);
static void update_state(uint8_t *buffer, display_event *current, display_event *prev);

void display_task(void *argument){
    osMessageQueueId_t *display_queue_id = (osMessageQueueId_t *)argument;
    sh1106_ctx sh1106 = {
      .a0 = {.pin = OLED_A0_Pin, .port = (void *)OLED_A0_GPIO_Port},
      .rst = {.pin = OLED_RES_Pin, .port = (void *)OLED_RES_GPIO_Port},
      .cs = {.pin = OLED_CS_Pin, .port = (void *)OLED_CS_GPIO_Port},
      .write = sh1106_write,
      .set = sh1106_set,
      .delay = sh1106_delay
    };
    sh1106_init(&sh1106);
    sh1106_send_cmd_list(&sh1106, init_cmds, sizeof(init_cmds));
    for(int i = 0; i < 8 * 128; i++){
        buffer[i] = 0x00;
    }
    gui_draw(buffer, LED, 52, 16, 38, 14);
    sh1106_update_region(&sh1106, buffer, 0, 0, 128, 64);
    display_event d_event;
    display_event prev = {.mode = MODE_LED_PWM, .val = 0};
    bool active = true;
    while(1){
        osStatus_t status = osMessageQueueGet(*display_queue_id, (void *)&d_event, NULL, DISPLAY_TIMEOUT_MS);
        if(status == osOK){
            active = true;
            sh1106_clear(buffer);
            update_state(buffer, &d_event, &prev);
            sh1106_update_region(&sh1106, buffer, 0, 0, 128, 64);
        }
        else if(status == osErrorTimeout && active){
            active = false;
            sh1106_clear(buffer);
            sh1106_update_region(&sh1106, buffer, 0, 0, 128, 64);
        }
    }
}

void sh1106_delay(uint32_t delay){
    osDelay(delay);
}

void sh1106_set(sh1106_pin *pin, bool state){
    if(state){
        LL_GPIO_SetOutputPin(pin->port, pin->pin);
    }
    else{
        LL_GPIO_ResetOutputPin(pin->port, pin->pin);
    }
}

void sh1106_write(sh1106_ctx *ctx, uint8_t *data, const uint8_t n_bytes){
    cs_low();
    spi_transmit(data, n_bytes);
    cs_high();
}

static void update_state(uint8_t *buffer, display_event *current, display_event *prev){
    sh1106_clear(buffer);
    switch(current->mode){
        case MODE_LED_DISPLAY:
            gui_draw(buffer, LED, 52, 16, 38, 14);
            switch(current->val){
                case LED_DISPLAY_OFF:
                    gui_draw(buffer, LED_OFF, 52, 16, 38, 34);
                    break;
                case LED_DISPLAY_BLINK:
                    gui_draw(buffer, LED_BLINK, 52, 16, 38, 34);
                    break;
                case LED_DISPLAY_ON:
                    gui_draw(buffer, LED_ON, 52, 16, 38, 34);
                    break;
                default:
                    break;
            }
            break;
        case MODE_LED_PWM:
            gui_draw(buffer, PWM, 52, 16, 38, 14);
            draw_digit(buffer, DISPLAY_DIGITS.bytes[current->val / 100], 42, 34);
            draw_digit(buffer, DISPLAY_DIGITS.bytes[(current->val / 10) % 10], 60, 34);
            draw_digit(buffer, DISPLAY_DIGITS.bytes[current->val % 10], 78, 34);
            break;
        default:
            break;
    }
    prev->mode = current->mode;
    prev->val = current->val;
}