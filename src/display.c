#include "display.h"
#include "cmsis_os2.h"
#include "main.h"

#define DISPLAY_TIMEOUT_MS 5000

static uint8_t LED[] = {
  0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 
  0xCF, 0xCF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 
  0xF0, 0xF0, 0xF0, 0xF0, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 
  0xF0, 0xF0, 0xF0, 0xF0, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xF3, 0xF3, 0xF3, 0xF3, 0xF3, 0xF3, 
  0xF3, 0xF3, 0xF3, 0xF3, 0xF3, 0xF3, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0xF0, 0xF0, 0xF0, 
  0xF0, 0xF0, 0xF0, 0xF0, 0x0F, 0x0F, 0x0F, 0x0F
};

static uint8_t PWM[] = {
  0xFF, 0xFF, 0xFF, 0xFF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 
  0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x0F, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 
  0x03, 0x03, 0x03, 0x03, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0xF0, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xF0, 0xF0, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 
  0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF
};

static uint8_t LED_OFF[] = {
  0xFF, 0xFF, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x83, 0x83, 
  0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x00, 0x00, 0xFF, 0xFF, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 
  0x83, 0x83, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xFF, 0xFF, 0x00, 0x00, 
  0xFF, 0xFF, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0xFF, 0xFF, 0x01, 0x01, 
  0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

static uint8_t LED_ON[] = {
  0xFF, 0xFF, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x18, 0x18, 
  0x60, 0x60, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xFF, 0xFF, 0x00, 0x00, 
  0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x06, 0x06, 0x18, 0x18, 0xFF, 0xFF, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

static uint8_t LED_BLINK[] = {
  0xFF, 0xFF, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x7C, 0x7C, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x18, 0x18, 0x60, 0x60, 0x80, 0x80, 
  0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 
  0x60, 0x60, 0x1F, 0x1F, 0xFF, 0xFF, 0xC1, 0xC1, 0xC1, 0xC1, 0xC1, 0xC1, 0x3E, 0x3E, 0x00, 0x00, 
  0xFF, 0xFF, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 
  0x00, 0x00, 0x01, 0x01, 0x06, 0x06, 0x18, 0x18, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x01, 0x01, 
  0x01, 0x01, 0x01, 0x01, 0x06, 0x06, 0xF8, 0xF8
};

// static uint8_t LED_BREATH[] = {
//   0xFF, 0xFF, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x7C, 0x7C, 0x00, 0x00, 0xFF, 0xFF, 0x83, 0x83, 
//   0x83, 0x83, 0x83, 0x83, 0x7C, 0x7C, 0x00, 0x00, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0xFF, 0xFF, 
//   0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x00, 0x00, 0xFF, 0xFF, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 
//   0x80, 0x80, 0xFF, 0xFF, 0xFF, 0xFF, 0xC1, 0xC1, 0xC1, 0xC1, 0xC1, 0xC1, 0x3E, 0x3E, 0x00, 0x00, 
//   0xFF, 0xFF, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0xFE, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
//   0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x01, 0x01, 
//   0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0xFF, 0xFF
// };

// static uint8_t LED_STATES

static gui_digits DISPLAY_DIGITS = {
  .spacing = 2,
  .bytes = {
    {0xFF, 0xFF, 0x0F, 0x0F, 0x0F, 0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0xF0, 0xF0, 0xF0, 0xFF, 0xFF},
    {0x0F, 0x0F, 0x0F, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0xF0, 0xF0, 0xF0, 0xFF, 0xFF, 0xF0, 0xF0, 0xF0},
    {0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF3, 0xF3, 0xF3, 0xF3, 0xF3, 0xF3},
    {0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xFF, 0xFF, 0xF3, 0xF3, 0xF3, 0xF3, 0xF3, 0xF3, 0xFF, 0xFF},
    {0xFF, 0xFF, 0xC0, 0xC0, 0xC0, 0xC0, 0xFF, 0xFF, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0xFF, 0xFF},
    {0xFF, 0xFF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xF3, 0xF3, 0xF3, 0xF3, 0xF3, 0xF3, 0xFF, 0xFF},
    {0xFF, 0xFF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xFF, 0xFF, 0xF3, 0xF3, 0xF3, 0xF3, 0xFF, 0xFF},
    {0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF},
    {0xFF, 0xFF, 0xCF, 0xCF, 0xCF, 0xCF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF3, 0xF3, 0xF3, 0xF3, 0xFF, 0xFF},
    {0xFF, 0xFF, 0xCF, 0xCF, 0xCF, 0xCF, 0xFF, 0xFF, 0xF3, 0xF3, 0xF3, 0xF3, 0xF3, 0xF3, 0xFF, 0xFF}
  }
};

uint8_t buffer[8 * 128];
static uint8_t init_cmds[] = {
    SH1106_SET_DISPLAY | 0x00,
    SH1106_SET_DIV_RATIO,
    0x50,
    SH1106_SET_MUX_RATIO,
    0x3F,
    SH1106_SET_DISPLAY_OFFSET,
    0x00,
    SH1106_SET_START_LINE | 0x00,
    SH1106_SET_REMAP | 0x00,
    SH1106_SET_COM_DIR | 0x00,
    SH1106_SET_COMMMON_PADS,
    0x12,
    SH1106_SET_CONTRAST,
    0x9F,
    SH1106_SET_CHARGE_PERIOD,
    0x22,
    SH1106_SET_VCOM,
    0x40,
    SH1106_SET_ENTIRE_DISPLAY | 0x00,
    SH1106_SET_NORMAL_DISPLAY | 0x00,
    SH1106_SET_DISPLAY | 0x01
};

void send_cmd(uint8_t cmd);
void send_data(uint8_t *data, uint8_t len);
void sh1106_rst(sh1106_pin *rst);
void sh1106_set(sh1106_pin *pin, bool state);
void sh1106_write(sh1106_ctx *ctx, uint8_t *data, const uint8_t n_bytes);
static void update_state(uint8_t *buffer, display_event *current, display_event *prev);

void display_task(void *argument){
    osMessageQueueId_t *display_queue_id = (osMessageQueueId_t *)argument;
    sh1106_ctx sh1106 = {
      .a0 = {.pin = OLED_A0_Pin, .port = (void *)OLED_A0_GPIO_Port},
      .rst = {.pin = OLED_RES_Pin, .port = (void *)OLED_RES_GPIO_Port},
      .cs = {.pin = OLED_CS_Pin, .port = (void *)OLED_CS_GPIO_Port},
      .write = sh1106_write,
      .init = sh1106_rst,
      .set = sh1106_set,
      // .spi = &hspi1
    };
    HAL_GPIO_WritePin(OLED_CS_GPIO_Port, OLED_CS_Pin, GPIO_PIN_RESET);
    sh1106_init(&sh1106);
    sh1106_send_cmd_list(&sh1106, init_cmds, sizeof(init_cmds));
    for(int i = 0; i < 8 * 128; i++){
        buffer[i] = 0x00;
    }
    // gui_draw_graphic(buffer, &DISPLAY_LED, 38, 14);
    gui_draw(buffer, LED, 52, 16, 38, 14);
    sh1106_update_region(&sh1106, buffer, 0, 0, 128, 64);
    display_event d_event;
    display_event prev = {.mode = MODE_LED_PWM, .val = 0};
    bool active = true;
    while(1){
        osStatus_t status = osMessageQueueGet(*display_queue_id, (void *)&d_event, NULL, DISPLAY_TIMEOUT_MS);
        if(status == osOK){
            // printf("DUPDATE\n");
            active = true;
            // draw_digit(buffer, digits[d_event.val / 100], 42, 34);
            // draw_digit(buffer, digits[(d_event.val / 10) % 10], 60, 34);
            // draw_digit(buffer, digits[d_event.val % 10], 78, 34);
            sh1106_clear(buffer);
            update_state(buffer, &d_event, &prev);
            sh1106_update_region(&sh1106, buffer, 0, 0, 128, 64);
            // prev.mode = d_event.mode;
            // prev.val = d_event.val;
        }
        else if(status == osErrorTimeout && active){
            // printf("DTIMEOUT\n");
            active = false;
            sh1106_clear(buffer);
            sh1106_update_region(&sh1106, buffer, 0, 0, 128, 64);
        }
    }
}

void send_cmd(uint8_t cmd){
  // HAL_GPIO_WritePin(OLED_CS_GPIO_Port, OLED_CS_Pin, GPIO_PIN_RESET);
  cs_low();
  HAL_GPIO_WritePin(GPIOA, GPIO_PIN_6, GPIO_PIN_RESET);
  spi_transmit(&cmd, 1);
  cs_high();
  // HAL_SPI_Transmit(&hspi1, &cmd, 1, 100);
  // HAL_GPIO_WritePin(OLED_CS_GPIO_Port, OLED_CS_Pin, GPIO_PIN_SET);
}

void send_data(uint8_t *data, uint8_t len){
  // HAL_GPIO_WritePin(OLED_CS_GPIO_Port, OLED_CS_Pin, GPIO_PIN_RESET);
  cs_low();
  HAL_GPIO_WritePin(GPIOA, GPIO_PIN_6, GPIO_PIN_SET);
  spi_transmit(data, len);
  cs_high();
  // HAL_SPI_Transmit(&hspi1, data, len, 100);
  // HAL_GPIO_WritePin(OLED_CS_GPIO_Port, OLED_CS_Pin, GPIO_PIN_SET);
}

void sh1106_rst(sh1106_pin *rst){
  HAL_GPIO_WritePin((GPIO_TypeDef *)rst->port, rst->pin, GPIO_PIN_RESET);
  HAL_Delay(1);
  HAL_GPIO_WritePin((GPIO_TypeDef *)rst->port, rst->pin, GPIO_PIN_SET);
}

void sh1106_set(sh1106_pin *pin, bool state){
  HAL_GPIO_WritePin((GPIO_TypeDef *)pin->port, pin->pin, state);
}

void sh1106_write(sh1106_ctx *ctx, uint8_t *data, const uint8_t n_bytes){
  spi_transmit(data, n_bytes);
  HAL_SPI_Transmit((SPI_HandleTypeDef *)(ctx->spi), data, n_bytes, 1000);
}

static void update_state(uint8_t *buffer, display_event *current, display_event *prev){
  sh1106_clear(buffer);
  switch(current->mode){
    case MODE_LED_DISPLAY:
      gui_draw(buffer, LED, 52, 16, 38, 14);
      switch(current->val){
        case LED_DISPLAY_OFF:
          gui_draw(buffer, LED_OFF, 52, 16, 38, 34);
          break;
        case LED_DISPLAY_BLINK:
          gui_draw(buffer, LED_BLINK, 52, 16, 38, 34);
          break;
        case LED_DISPLAY_ON:
          gui_draw(buffer, LED_ON, 52, 16, 38, 34);
          break;
        default:
          break;
      }
      break;
    case MODE_LED_PWM:
      gui_draw(buffer, PWM, 52, 16, 38, 14);
      draw_digit(buffer, DISPLAY_DIGITS.bytes[current->val / 100], 42, 34);
      draw_digit(buffer, DISPLAY_DIGITS.bytes[(current->val / 10) % 10], 60, 34);
      draw_digit(buffer, DISPLAY_DIGITS.bytes[current->val % 10], 78, 34);
      break;
    default:
      break;
  }
  prev->mode = current->mode;
  prev->val = current->val;
}